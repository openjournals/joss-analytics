---
title: "JOSS submission analytics"
date: "`r Sys.time()`"
output: 
  html_document:
    code_folding: hide
    theme: united
    highlight: tango
    toc: true
    toc_float: true
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, dev = c("png", "pdf"))
```

# Introduction

In this report, we extract information about published JOSS papers and generate  graphics as well as a summary table that can be downloaded and used for further analyses. 

# Load required R packages

```{r load-packages, class.source = 'fold-show'}
suppressPackageStartupMessages({
    library(tibble)
    library(rcrossref)
    library(dplyr)
    library(tidyr)
    library(ggplot2)
    library(lubridate)
    library(gh)
    library(purrr)
    library(jsonlite)
    library(DT)
    library(plotly)
    library(citecorp)
    library(readr)
    library(rworldmap)
    library(gt)
    library(stringr)
    library(openalexR)
})
```

```{r source-track, class.source = 'fold-hide'}
## Keep track of the source of each column
source_track <- c()

## Determine whether to add a caption with today's date to the (non-interactive) plots
add_date_caption <- TRUE
if (add_date_caption) {
    dcap <- lubridate::today()
} else {
    dcap <- ""
}
```

```{r}
## Get list of countries and populations (2022) from the rworldmap/gt packages
data("countrySynonyms")
country_names <- countrySynonyms |>
    select(-ID) |>
    pivot_longer(names_to = "tmp", values_to = "name", -ISO3) |>
    filter(name != "") |>
    select(-tmp)

## Country population data from the World Bank (https://data.worldbank.org/indicator/SP.POP.TOTL),
## distributed via the gt R package
country_populations <- countrypops |> 
    filter(year == 2022)
```

```{r}
## Read archived version of summary data frame, to use for filling in 
## information about software repositories (due to limit on API requests)
## Sort by the date when software repo info was last obtained
papers_archive <- readRDS(gzcon(url("https://github.com/openjournals/joss-analytics/blob/gh-pages/joss_submission_analytics.rds?raw=true"))) %>%
    dplyr::arrange(!is.na(repo_info_obtained), repo_info_obtained)

## Similarly for citation analysis, to avoid having to pull down the 
## same information multiple times
citations_archive <- readr::read_delim(
    url("https://github.com/openjournals/joss-analytics/blob/gh-pages/joss_submission_citations.tsv?raw=true"),
    col_types = cols(.default = "c"), col_names = TRUE,
    delim = "\t")
```

# Collect information about papers

## Pull down paper info from Crossref and citation information from OpenAlex

We get the information about published JOSS papers from Crossref, using the `rcrossref` R package. The `openalexR` R package is used to extract citation counts from OpenAlex.

```{r pull-crossref, class.source = 'fold-show'}
## Fetch JOSS papers from Crossref
## Only 1000 papers at the time can be pulled down
lim <- 1000
papers <- rcrossref::cr_works(filter = c(issn = "2475-9066"), 
                              limit = lim)$data
i <- 1
while (nrow(papers) == i * lim) {
    papers <- dplyr::bind_rows(
        papers, 
        rcrossref::cr_works(filter = c(issn = "2475-9066"), 
                            limit = lim, offset = i * lim)$data)
    i <- i + 1
}
papers <- papers %>%
    dplyr::filter(type == "journal-article") 
dim(papers)

## A few papers don't have DOIs - generate them from the URL
noaltid <- which(is.na(papers$alternative.id))
papers$alternative.id[noaltid] <- gsub("http://dx.doi.org/", "",
                                       papers$url[noaltid])

## Get citation info from Crossref and merge with paper details
# cit <- rcrossref::cr_citation_count(doi = papers$alternative.id)
# papers <- papers %>% dplyr::left_join(
#     cit %>% dplyr::rename(citation_count = count), 
#     by = c("alternative.id" = "doi")
# )

## Remove one duplicated paper
papers <- papers %>% dplyr::filter(alternative.id != "10.21105/joss.00688")
dim(papers)

source_track <- c(source_track, 
                  structure(rep("crossref", ncol(papers)), 
                            names = colnames(papers)))
```

```{r}
## Get info from openalexR and merge with paper details
## Helper function to extract countries from affiliations. Note that this 
## information is not available for all papers.
.get_countries <- function(df, wh = "first") {
    if (length(df) == 1 && is.na(df)) {
        ""
    } else {
        if (wh == "first") {
            ## Only first affiliation for each author
            tmp <- df |> 
                dplyr::filter(!duplicated(au_id) & !is.na(institution_country_code)) |>
                pull(institution_country_code)
        } else {
            ## All affiliations
            tmp <- df |> 
                dplyr::filter(!is.na(institution_country_code)) |>
                pull(institution_country_code)
        }
        if (length(tmp) > 0) {
            tmp |>
                unique() |>
                paste(collapse = ";")
        } else {
            ""
        }
    }
}

oa <- oa_fetch(entity = "works", 
               primary_location.source.id = "s4210214273") |>
    mutate(affil_countries_all = vapply(author, .get_countries, "", wh = "all"),
           affil_countries_first = vapply(author, .get_countries, "", wh = "first"))

papers <- papers %>% dplyr::left_join(
    oa %>% dplyr::mutate(alternative.id = sub("https://doi.org/", "", doi)) %>%
        dplyr::select(alternative.id, cited_by_count, id,
                      affil_countries_all, affil_countries_first) %>%
        dplyr::rename(citation_count = cited_by_count, 
                      openalex_id = id),
    by = "alternative.id"
)

source_track <- c(source_track, 
                  structure(rep("OpenAlex", length(setdiff(colnames(papers),
                                                           names(source_track)))), 
                            names = setdiff(colnames(papers), names(source_track))))
```

## Pull down info from Whedon API

For each published paper, we use the Whedon API to get information about pre-review and review issue numbers, corresponding software repository etc.

```{r pull-whedon, class.source = 'fold-show'}
whedon <- list()
p <- 1
a0 <- NULL
a <- jsonlite::fromJSON(
    url(paste0("https://joss.theoj.org/papers/published.json?page=", p)),
    simplifyDataFrame = FALSE
)
while (length(a) > 0 && !identical(a, a0)) {
    whedon <- c(whedon, a)
    p <- p + 1
    a0 <- a
    a <- tryCatch({
        jsonlite::fromJSON(
            url(paste0("https://joss.theoj.org/papers/published.json?page=", p)),
            simplifyDataFrame = FALSE
        )}, 
        error = function(e) return(numeric(0))
    )
}

whedon <- do.call(dplyr::bind_rows, lapply(whedon, function(w) {
    data.frame(api_title = w$title, 
               api_state = w$state,
               editor = paste(w$editor, collapse = ","),
               reviewers = paste(w$reviewers, collapse = ","),
               nbr_reviewers = length(w$reviewers),
               repo_url = w$software_repository,
               review_issue_id = sub("https://github.com/openjournals/joss-reviews/issues/", 
                                     "", w$paper_review),
               doi = w$doi,
               prereview_issue_id = ifelse(!is.null(w$meta_review_issue_id),
                                           w$meta_review_issue_id, NA_integer_),
               languages = gsub(", ", ",", w$languages),
               archive_doi = w$software_archive)
}))
dim(whedon)
dim(whedon %>% distinct())
whedon$repo_url[duplicated(whedon$repo_url)]

papers <- papers %>% dplyr::left_join(whedon, by = c("alternative.id" = "doi"))
dim(papers)
dim(papers %>% distinct())
papers$repo_url[duplicated(papers$repo_url)]

source_track <- c(source_track, 
                  structure(rep("whedon", length(setdiff(colnames(papers),
                                                         names(source_track)))), 
                            names = setdiff(colnames(papers), names(source_track))))
```

## Combine with info from GitHub issues

From each pre-review and review issue, we extract information about review times and assigned labels. 

```{r pull-github, class.source = 'fold-show', message = FALSE}
## Pull down info on all issues in the joss-reviews repository
issues <- gh("/repos/openjournals/joss-reviews/issues", 
             .limit = 15000, state = "all")
```

```{r extract-github, class.source = 'fold-show', message = FALSE}
## From each issue, extract required information
iss <- do.call(dplyr::bind_rows, lapply(issues, function(i) {
    data.frame(title = i$title, 
               number = i$number,
               state = i$state,
               opened = i$created_at,
               closed = ifelse(!is.null(i$closed_at),
                               i$closed_at, NA_character_),
               ncomments = i$comments,
               labels = paste(setdiff(
                   vapply(i$labels, getElement, 
                          name = "name", character(1L)),
                   c("review", "pre-review", "query-scope", "paused")),
                   collapse = ","))
}))

## Split into REVIEW, PRE-REVIEW, and other issues (the latter category 
## is discarded)
issother <- iss %>% dplyr::filter(!grepl("\\[PRE REVIEW\\]", title) & 
                                      !grepl("\\[REVIEW\\]", title))
dim(issother)
head(issother)

## For REVIEW issues, generate the DOI of the paper from the issue number
getnbrzeros <- function(s) {
    paste(rep(0, 5 - nchar(s)), collapse = "")
}
issrev <- iss %>% dplyr::filter(grepl("\\[REVIEW\\]", title)) %>%
    dplyr::mutate(nbrzeros = purrr::map_chr(number, getnbrzeros)) %>%
    dplyr::mutate(alternative.id = paste0("10.21105/joss.", 
                                          nbrzeros,
                                          number)) %>%
    dplyr::select(-nbrzeros) %>% 
    dplyr::mutate(title = gsub("\\[REVIEW\\]: ", "", title)) %>%
    dplyr::rename_at(vars(-alternative.id), ~ paste0("review_", .))
```

```{r get-rejection-info, class.source = 'fold-show', message = FALSE}
## For pre-review and review issues, respectively, get the number of 
## issues closed each month, and the number of those that have the 
## 'rejected' label
review_rejected <- iss %>% 
    dplyr::filter(grepl("\\[REVIEW\\]", title)) %>% 
    dplyr::filter(!is.na(closed)) %>%
    dplyr::mutate(closedmonth = lubridate::floor_date(as.Date(closed), "month")) %>%
    dplyr::group_by(closedmonth) %>%
    dplyr::summarize(nbr_issues_closed = length(labels),
                     nbr_rejections = sum(grepl("rejected", labels))) %>%
    dplyr::mutate(itype = "review")

prereview_rejected <- iss %>% 
    dplyr::filter(grepl("\\[PRE REVIEW\\]", title)) %>% 
    dplyr::filter(!is.na(closed)) %>%
    dplyr::mutate(closedmonth = lubridate::floor_date(as.Date(closed), "month")) %>%
    dplyr::group_by(closedmonth) %>%
    dplyr::summarize(nbr_issues_closed = length(labels),
                     nbr_rejections = sum(grepl("rejected", labels))) %>%
    dplyr::mutate(itype = "pre-review")

all_rejected <- dplyr::bind_rows(review_rejected, prereview_rejected)
```

```{r extract-github-2, class.source = 'fold-show', message = FALSE}
## For PRE-REVIEW issues, add information about the corresponding REVIEW 
## issue number
isspre <- iss %>% dplyr::filter(grepl("\\[PRE REVIEW\\]", title)) %>%
    dplyr::filter(!grepl("withdrawn", labels)) %>%
    dplyr::filter(!grepl("rejected", labels))
## Some titles have multiple pre-review issues. In these cases, keep the latest
isspre <- isspre %>% dplyr::arrange(desc(number)) %>% 
    dplyr::filter(!duplicated(title)) %>% 
    dplyr::mutate(title = gsub("\\[PRE REVIEW\\]: ", "", title)) %>%
    dplyr::rename_all(~ paste0("prerev_", .))

papers <- papers %>% dplyr::left_join(issrev, by = "alternative.id") %>% 
    dplyr::left_join(isspre, by = c("prereview_issue_id" = "prerev_number")) %>%
    dplyr::mutate(prerev_opened = as.Date(prerev_opened),
                  prerev_closed = as.Date(prerev_closed),
                  review_opened = as.Date(review_opened),
                  review_closed = as.Date(review_closed)) %>% 
    dplyr::mutate(days_in_pre = prerev_closed - prerev_opened,
                  days_in_rev = review_closed - review_opened,
                  to_review = !is.na(review_opened))
dim(papers)
dim(papers %>% distinct())

source_track <- c(source_track, 
                  structure(rep("joss-github", length(setdiff(colnames(papers),
                                                              names(source_track)))), 
                            names = setdiff(colnames(papers), names(source_track))))
```

## Add information from software repositories

```{r check-software-repos, class.source = 'fold-show', message = FALSE}
## Reorder so that software repositories that were interrogated longest 
## ago are checked first
tmporder <- order(match(papers$alternative.id, papers_archive$alternative.id),
                  na.last = FALSE)
software_urls <- papers$repo_url[tmporder]
software_urls[duplicated(software_urls)]
is_github <- grepl("github", software_urls)
length(is_github)
sum(is_github)
software_urls[!is_github]
```

```{r get-software-repos, class.source = 'fold-show', message = FALSE, results = 'hide', warning = FALSE}
df <- do.call(dplyr::bind_rows, lapply(software_urls[is_github], function(u) {
    u0 <- gsub("^http://", "https://", gsub("\\.git$", "", gsub("/$", "", u)))
    if (grepl("/tree/", u0)) {
        u0 <- strsplit(u0, "/tree/")[[1]][1]
    }
    if (grepl("/blob/", u0)) {
        u0 <- strsplit(u0, "/blob/")[[1]][1]
    }
    info <- try({
        gh(gsub("(https://)?(www.)?github.com/", "/repos/", u0))
    })
    languages <- try({
        gh(paste0(gsub("(https://)?(www.)?github.com/", "/repos/", u0), "/languages"), 
           .limit = 500)
    })
    topics <- try({
        gh(paste0(gsub("(https://)?(www.)?github.com/", "/repos/", u0), "/topics"), 
           .accept = "application/vnd.github.mercy-preview+json", .limit = 500)
    })
    contribs <- try({
        gh(paste0(gsub("(https://)?(www.)?github.com/", "/repos/", u0), "/contributors"), 
           .limit = 500)
    })
    if (!is(info, "try-error") && length(info) > 1) {
        if (!is(contribs, "try-error")) {
            if (length(contribs) == 0) {
                repo_nbr_contribs <- repo_nbr_contribs_2ormore <- NA_integer_
            } else {
                repo_nbr_contribs <- length(contribs)
                repo_nbr_contribs_2ormore <- sum(vapply(contribs, function(x) x$contributions >= 2, NA_integer_))
                if (is.na(repo_nbr_contribs_2ormore)) {
                    print(contribs)
                }
            }
        } else {
            repo_nbr_contribs <- repo_nbr_contribs_2ormore <- NA_integer_
        }
        
        if (!is(languages, "try-error")) {
            if (length(languages) == 0) {
                repolang <- ""
            } else {
                repolang <- paste(paste(names(unlist(languages)), 
                                        unlist(languages), sep = ":"), collapse = ",")
            }
        } else {
            repolang <- ""
        }
        
        if (!is(topics, "try-error")) {
            if (length(topics$names) == 0) {
                repotopics <- ""
            } else {
                repotopics <- paste(unlist(topics$names), collapse = ",")
            }
        } else {
            repotopics <- ""
        }
        
        data.frame(repo_url = u, 
                   repo_created = info$created_at,
                   repo_updated = info$updated_at,
                   repo_pushed = info$pushed_at,
                   repo_nbr_stars = info$stargazers_count,
                   repo_language = ifelse(!is.null(info$language),
                                          info$language, NA_character_),
                   repo_languages_bytes = repolang,
                   repo_topics = repotopics,
                   repo_license = ifelse(!is.null(info$license),
                                         info$license$key, NA_character_),
                   repo_nbr_contribs = repo_nbr_contribs,
                   repo_nbr_contribs_2ormore = repo_nbr_contribs_2ormore
        )
    } else {
        NULL
    }
})) %>%
    dplyr::mutate(repo_created = as.Date(repo_created),
                  repo_updated = as.Date(repo_updated),
                  repo_pushed = as.Date(repo_pushed)) %>%
    dplyr::distinct() %>%
    dplyr::mutate(repo_info_obtained = lubridate::today())
```

```{r get-software-repos-print, class.source = 'fold-show', message = FALSE, warning = FALSE}
if (length(unique(df$repo_url)) != length(df$repo_url)) {
    print(length(unique(df$repo_url)))
    print(length(df$repo_url))
    print(df$repo_url[duplicated(df$repo_url)])
}
stopifnot(length(unique(df$repo_url)) == length(df$repo_url))
dim(df)

## For papers not in df (i.e., for which we didn't get a valid response
## from the GitHub API query), use information from the archived data frame
dfarchive <- papers_archive %>% 
    dplyr::select(colnames(df)[colnames(df) %in% colnames(papers_archive)]) %>%
    dplyr::filter(!(repo_url %in% df$repo_url)) %>%
    dplyr::arrange(desc(repo_info_obtained)) %>%
    dplyr::filter(!duplicated(repo_url))
head(dfarchive)
dim(dfarchive)
df <- dplyr::bind_rows(df, dfarchive)
stopifnot(length(unique(df$repo_url)) == length(df$repo_url))
dim(df)

papers <- papers %>% dplyr::left_join(df, by = "repo_url")
dim(papers)

source_track <- c(source_track, 
                  structure(rep("sw-github", length(setdiff(colnames(papers),
                                                            names(source_track)))), 
                            names = setdiff(colnames(papers), names(source_track))))
```

## Clean up a bit

```{r clean-up, class.source = 'fold-show'}
## Convert publication date to Date format
## Add information about the half year (H1, H2) of publication
## Count number of authors
papers <- papers %>% dplyr::select(-reference, -license, -link) %>%
    dplyr::mutate(published.date = as.Date(published.print)) %>% 
    dplyr::mutate(
        halfyear = paste0(year(published.date), 
                          ifelse(month(published.date) <= 6, "H1", "H2"))
    ) %>% dplyr::mutate(
        halfyear = factor(halfyear, 
                          levels = paste0(rep(sort(unique(year(published.date))), 
                                              each = 2), c("H1", "H2")))
    ) %>% dplyr::mutate(nbr_authors = vapply(author, function(a) nrow(a), NA_integer_))
dim(papers)
dupidx <- which(papers$alternative.id %in% papers$alternative.id[duplicated(papers)])
papers[dupidx, ] %>% arrange(alternative.id) %>% head(n = 10)

papers <- papers %>% dplyr::distinct()
dim(papers)

source_track <- c(source_track, 
                  structure(rep("cleanup", length(setdiff(colnames(papers),
                                                          names(source_track)))), 
                            names = setdiff(colnames(papers), names(source_track))))
```

# Tabulate number of missing values

In some cases, fetching information from (e.g.) the GitHub API fails for a subset of the publications. There are also other reasons for missing values (for example, the earliest submissions do not have an associated pre-review issue). The table below lists the number of missing values for each of the variables in the data frame.

```{r nbr-missing, class.source = 'fold-hide'}
DT::datatable(
    data.frame(variable = colnames(papers),
               nbr_missing = colSums(is.na(papers))) %>%
        dplyr::mutate(source = source_track[variable]),
    escape = FALSE, rownames = FALSE, 
    filter = list(position = 'top', clear = FALSE),
    options = list(scrollX = TRUE)
)
```


# Number of published papers per month and year

```{r papers-month, class.source = 'fold-hide', fig.width = 10, message = FALSE}
ggplot(papers %>% 
           dplyr::mutate(pubmonth = lubridate::floor_date(published.date, "month")) %>%
           dplyr::group_by(pubmonth) %>%
           dplyr::summarize(npub = n()), 
       aes(x = factor(pubmonth), y = npub)) + 
    geom_bar(stat = "identity") + theme_minimal() + 
    labs(x = "", y = "Number of published papers per month", caption = dcap) + 
    theme(axis.title = element_text(size = 15),
          axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

```{r papers-year, class.source = 'fold-hide', fig.width = 8, message = FALSE}
ggplot(papers %>% 
           dplyr::mutate(pubyear = lubridate::year(published.date)) %>%
           dplyr::group_by(pubyear) %>%
           dplyr::summarize(npub = n()), 
       aes(x = factor(pubyear), y = npub)) + 
    geom_bar(stat = "identity") + theme_minimal() + 
    labs(x = "", y = "Number of published papers per year", caption = dcap) + 
    theme(axis.title = element_text(size = 15),
          axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

The plots below illustrate the fraction of pre-review and review issues closed 
during each month that have the 'rejected' label attached. 

```{r rejections, class.source = 'fold-hide', fig.width = 10, fig.height = 8, message = FALSE}
ggplot(all_rejected, 
       aes(x = factor(closedmonth), y = nbr_rejections/nbr_issues_closed)) + 
    geom_bar(stat = "identity") + 
    theme_minimal() + 
    facet_wrap(~ itype, ncol = 1) + 
    labs(x = "Month of issue closing", y = "Fraction of issues rejected",
         caption = dcap) + 
    theme(axis.title = element_text(size = 15),
          axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))
```

# Citation distribution

Papers with 20 or more citations are grouped in the ">=20" category.

```{r citation-distribution, class.source = 'fold-hide'}
ggplot(papers %>% 
           dplyr::mutate(citation_count = replace(citation_count,
                                                  citation_count >= 20, ">=20")) %>%
           dplyr::mutate(citation_count = factor(citation_count, 
                                                 levels = c(0:20, ">=20"))) %>%
           dplyr::group_by(citation_count) %>%
           dplyr::tally(),
       aes(x = citation_count, y = n)) + 
    geom_bar(stat = "identity") + 
    theme_minimal() + 
    labs(x = "OpenAlex citation count", y = "Number of publications", caption = dcap)
```


# Most cited papers

The table below sorts the JOSS papers in decreasing order by the number of citations in OpenAlex.

```{r most-cited, class.source = 'fold-hide'}
DT::datatable(
    papers %>% 
        dplyr::mutate(url = paste0("<a href='", url, "' target='_blank'>", 
                                   url,"</a>")) %>% 
        dplyr::arrange(desc(citation_count)) %>% 
        dplyr::select(title, url, published.date, citation_count),
    escape = FALSE,
    filter = list(position = 'top', clear = FALSE),
    options = list(scrollX = TRUE)
)
```

# Citation count vs time since publication

```{r citations-vs-time, class.source = 'fold-hide', message = FALSE}
plotly::ggplotly(
    ggplot(papers, aes(x = published.date, y = citation_count, label = title)) + 
        geom_point(alpha = 0.5) + theme_bw() + scale_y_sqrt() + 
        geom_smooth() + 
        labs(x = "Date of publication", y = "OpenAlex citation count", caption = dcap) + 
        theme(axis.title = element_text(size = 15)),
    tooltip = c("label", "x", "y")
)
```

# Power law of citation count within each half year

Here, we plot the citation count for all papers published within each half year, sorted in decreasing order. 

```{r power-law-citations, class.source = 'fold-hide', fig.width = 10, fig.height = 10}
ggplot(papers %>% dplyr::group_by(halfyear) %>% 
           dplyr::arrange(desc(citation_count)) %>%
           dplyr::mutate(idx = seq_along(citation_count)), 
       aes(x = idx, y = citation_count)) + 
    geom_point(alpha = 0.5) + 
    facet_wrap(~ halfyear, scales = "free") + 
    theme_bw() + 
    labs(x = "Index", y = "OpenAlex citation count", caption = dcap)
```


# Pre-review/review time over time

In these plots we investigate whether the time a submission spends in the pre-review or review stage (or their sum) has changed over time. The blue curve corresponds to a rolling median for submissions over 120 days. 

```{r smoothing-helpers, class.source = 'fold-hide'}
## Helper functions (modified from https://stackoverflow.com/questions/65147186/geom-smooth-with-median-instead-of-mean)
rolling_median <- function(formula, data, xwindow = 120, ...) {
    ## Get order of x-values and sort x/y
    ordr <- order(data$x)
    x <- data$x[ordr]
    y <- data$y[ordr]
    
    ## Initialize vector for smoothed y-values
    ys <- rep(NA, length(x))
    ## Calculate median y-value for each unique x-value
    for (xs in setdiff(unique(x), NA)) {
        ## Get x-values in the window, and calculate median of corresponding y
        j <- ((xs - xwindow/2) < x) & (x < (xs + xwindow/2))
        ys[x == xs] <- median(y[j], na.rm = TRUE)
    }
    y <- ys
    structure(list(x = x, y = y, f = approxfun(x, y)), class = "rollmed")
}

predict.rollmed <- function(mod, newdata, ...) {
    setNames(mod$f(newdata$x), newdata$x)
}
```

```{r review-time, class.source = 'fold-hide', message = FALSE, warning = FALSE}
ggplot(papers, aes(x = prerev_opened, y = as.numeric(days_in_pre))) + 
    geom_point() + 
    geom_smooth(formula = y ~ x, method = "rolling_median", 
                se = FALSE, method.args = list(xwindow = 120)) + 
    theme_bw() + 
    labs(x = "Date of pre-review opening", y = "Number of days in pre-review", 
         caption = dcap) + 
    theme(axis.title = element_text(size = 15))

ggplot(papers, aes(x = review_opened, y = as.numeric(days_in_rev))) + 
    geom_point() +
    geom_smooth(formula = y ~ x, method = "rolling_median", 
                se = FALSE, method.args = list(xwindow = 120)) +
    theme_bw() + 
    labs(x = "Date of review opening", y = "Number of days in review", 
         caption = dcap) + 
    theme(axis.title = element_text(size = 15))

ggplot(papers, aes(x = prerev_opened, 
                   y = as.numeric(days_in_pre) + as.numeric(days_in_rev))) + 
    geom_point() +
    geom_smooth(formula = y ~ x, method = "rolling_median", 
                se = FALSE, method.args = list(xwindow = 120)) +
    theme_bw() + 
    labs(x = "Date of pre-review opening", y = "Number of days in pre-review + review", 
         caption = dcap) + 
    theme(axis.title = element_text(size = 15))
```

# Languages

Next, we consider the languages used by the submissions, both as reported by Whedon and based on the information encoded in available GitHub repositories (for the latter, we also record the number of bytes of code written in each language). Note that a given submission can use multiple languages. 

```{r languages, class.source = 'fold-hide', fig.width = 9, message = FALSE}
## Language information from Whedon
sspl <- strsplit(papers$languages, ",")
all_languages <- unique(unlist(sspl))
langs <- do.call(dplyr::bind_rows, lapply(all_languages, function(l) {
    data.frame(language = l,
               nbr_submissions_Whedon = sum(vapply(sspl, function(v) l %in% v, 0)))
}))

## Language information from GitHub software repos
a <- lapply(strsplit(papers$repo_languages_bytes, ","), function(w) strsplit(w, ":"))
a <- a[sapply(a, length) > 0]
langbytes <- as.data.frame(t(as.data.frame(a))) %>% 
    setNames(c("language", "bytes")) %>%
    dplyr::mutate(bytes = as.numeric(bytes)) %>%
    dplyr::filter(!is.na(language)) %>%
    dplyr::group_by(language) %>%
    dplyr::summarize(nbr_bytes_GitHub = sum(bytes),
                     nbr_repos_GitHub = length(bytes)) %>%
    dplyr::arrange(desc(nbr_bytes_GitHub))

langs <- dplyr::full_join(langs, langbytes, by = "language")
```

```{r language-plot, class.source = 'fold-hide', message = FALSE}
ggplot(langs %>% dplyr::arrange(desc(nbr_submissions_Whedon)) %>%
           dplyr::filter(nbr_submissions_Whedon > 10) %>%
           dplyr::mutate(language = factor(language, levels = language)),
       aes(x = language, y = nbr_submissions_Whedon)) + 
    geom_bar(stat = "identity") + 
    theme_bw() + 
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) + 
    labs(x = "", y = "Number of submissions", caption = dcap) + 
    theme(axis.title = element_text(size = 15))
```

```{r language-bytes, class.source = 'fold-hide', message = FALSE}
DT::datatable(
    langs %>% dplyr::arrange(desc(nbr_bytes_GitHub)),
    escape = FALSE,
    filter = list(position = 'top', clear = FALSE),
    options = list(scrollX = TRUE)
)
```

```{r language-bytes-plot, class.source = 'fold-hide', message = FALSE, warning = FALSE}
ggplot(langs, aes(x = nbr_repos_GitHub, y = nbr_bytes_GitHub)) + 
    geom_point() + scale_x_log10() + scale_y_log10() + geom_smooth() + 
    theme_bw() + 
    labs(x = "Number of repos using the language",
         y = "Total number of bytes of code\nwritten in the language", 
         caption = dcap) + 
    theme(axis.title = element_text(size = 15))
```

# Association between number of citations and number of stars of the GitHub repo

```{r citation-stars, class.source = 'fold-hide'}
ggplotly(
    ggplot(papers, aes(x = citation_count, y = repo_nbr_stars,
                       label = title)) + 
        geom_point(alpha = 0.5) + scale_x_sqrt() + scale_y_sqrt() + 
        theme_bw() + 
        labs(x = "OpenAlex citation count", y = "Number of stars, GitHub repo", 
             caption = dcap) + 
        theme(axis.title = element_text(size = 15)),
    tooltip = c("label", "x", "y")
)
```

# Distribution of time between GitHub repo creation and JOSS submission

```{r creation-to-submission, class.source = 'fold-hide', warning = FALSE}
ggplot(papers, aes(x = as.numeric(prerev_opened - repo_created))) +
    geom_histogram(bins = 50) + 
    theme_bw() + 
    labs(x = "Time (days) from repo creation to JOSS pre-review start", 
         caption = dcap) + 
    theme(axis.title = element_text(size = 15))
```

# Distribution of time between JOSS acceptance and last commit

```{r acceptance-to-commit, class.source = 'fold-hide', warning = FALSE, fig.width = 8, fig.height = 8}
ggplot(papers, aes(x = as.numeric(repo_pushed - review_closed))) +
    geom_histogram(bins = 50) + 
    theme_bw() + 
    labs(x = "Time (days) from closure of JOSS review to most recent commit in repo",
         caption = dcap) + 
    theme(axis.title = element_text(size = 15)) + 
    facet_wrap(~ year(published.date), scales = "free_y")
```

# Number of authors per paper

List the papers with the largest number of authors, and display the distribution of the number of authors per paper, for papers with at most 20 authors.

```{r nbr-authors-top, class.source = 'fold-show'}
## Papers with largest number of authors
papers %>% dplyr::arrange(desc(nbr_authors)) %>% 
    dplyr::select(title, published.date, url, nbr_authors) %>%
    as.data.frame() %>% head(10)
```

```{r nbr-authors, class.source = 'fold-hide', message = FALSE, fig.width = 8, fig.height = 8}
nbins <- max(papers$nbr_authors[papers$nbr_authors <= 20])
ggplot(papers %>% dplyr::filter(nbr_authors <= 20),
       aes(x = nbr_authors)) + 
    geom_histogram(bins = nbins, fill = "lightgrey", color = "grey50") + 
    theme_bw() + 
    facet_wrap(~ year(published.date), scales = "free_y") + 
    theme(axis.title = element_text(size = 15)) + 
    labs(x = "Number of authors",
         y = "Number of publications with\na given number of authors", 
         caption = dcap)
```

```{r nbr-authors-all, class.source = 'fold-hide', message = FALSE}
ggplot(papers %>% 
           dplyr::mutate(nbr_authors = replace(nbr_authors, nbr_authors > 5, ">5")) %>%
           dplyr::mutate(nbr_authors = factor(nbr_authors, levels = c("1", "2", "3", 
                                                                      "4", "5", ">5"))) %>%
           dplyr::mutate(year = year(published.date)) %>%
           dplyr::mutate(year = factor(year)) %>%
           dplyr::group_by(year, nbr_authors, .drop = FALSE) %>%
           dplyr::summarize(n = n()) %>%
           dplyr::mutate(freq = n/sum(n)) %>%
           dplyr::mutate(year = as.integer(as.character(year))), 
       aes(x = year, y = freq, fill = nbr_authors)) + geom_area() + 
    theme_minimal() + 
    scale_fill_brewer(palette = "Set1", name = "Number of\nauthors", 
                      na.value = "grey") + 
    theme(axis.title = element_text(size = 15)) + 
    labs(x = "Year", y = "Fraction of submissions", caption = dcap)

```

# Number of authors vs number of contributors to the GitHub repo

Note that points are slightly jittered to reduce the overlap. 

```{r nbr-authors-contribs, class.source = 'fold-hide', message = FALSE}
plotly::ggplotly(
    ggplot(papers, aes(x = nbr_authors, y = repo_nbr_contribs_2ormore, label = title)) + 
        geom_abline(slope = 1, intercept = 0) + 
        geom_jitter(width = 0.05, height = 0.05, alpha = 0.5) + 
        # geom_point(alpha = 0.5) + 
        theme_bw() + 
        scale_x_sqrt() + scale_y_sqrt() + 
        labs(x = "Number of authors", 
             y = "Number of contributors\nwith at least 2 commits", 
             caption = dcap) + 
        theme(axis.title = element_text(size = 15)),
    tooltip = c("label", "x", "y")
)
```

# Number of reviewers per paper

Submissions associated with rOpenSci and pyOpenSci are not considered here, since they are not explicitly reviewed at JOSS. 

```{r nbr-reviewers, class.source = 'fold-hide', message = FALSE, fig.width = 8, fig.height = 8}
ggplot(papers %>%
           dplyr::filter(!grepl("rOpenSci|pyOpenSci", prerev_labels)) %>%
           dplyr::mutate(year = year(published.date)),
       aes(x = nbr_reviewers)) + geom_bar() + 
    facet_wrap(~ year) + theme_bw() + 
    labs(x = "Number of reviewers", y = "Number of submissions", caption = dcap)
```

# Most active reviewers

Submissions associated with rOpenSci and pyOpenSci are not considered here, since they are not explicitly reviewed at JOSS. 

```{r most-reviewers, class.source = 'fold-hide', message = FALSE}
reviewers <- papers %>% 
    dplyr::filter(!grepl("rOpenSci|pyOpenSci", prerev_labels)) %>%
    dplyr::mutate(year = year(published.date)) %>%
    dplyr::select(reviewers, year) %>%
    tidyr::separate_rows(reviewers, sep = ",")

## Most active reviewers
DT::datatable(
    reviewers %>% dplyr::group_by(reviewers) %>%
        dplyr::summarize(nbr_reviews = length(year),
                         timespan = paste(unique(c(min(year), max(year))), 
                                          collapse = " - ")) %>%
        dplyr::arrange(desc(nbr_reviews)),
    escape = FALSE, rownames = FALSE, 
    filter = list(position = 'top', clear = FALSE),
    options = list(scrollX = TRUE)
)
```

# Number of papers per editor and year

```{r papers-per-editor, class.source = 'fold-hide', message = FALSE, fig.width = 16, fig.height = 15}
ggplot(papers %>% 
           dplyr::mutate(year = year(published.date),
                         `r/pyOpenSci` = factor(
                             grepl("rOpenSci|pyOpenSci", prerev_labels),
                             levels = c("TRUE", "FALSE"))), 
       aes(x = editor)) + geom_bar(aes(fill = `r/pyOpenSci`)) + 
    theme_bw() + facet_wrap(~ year, ncol = 1) + 
    scale_fill_manual(values = c(`TRUE` = "grey65", `FALSE` = "grey35")) + 
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) + 
    labs(x = "Editor", y = "Number of submissions", caption = dcap)
```


# Distribution of software repo licenses

```{r repo-license, class.source = 'fold-hide', warning = FALSE, message = FALSE, fig.width = 8, fig.height = 8}
all_licenses <- sort(unique(papers$repo_license))
license_levels = c(grep("apache", all_licenses, value = TRUE),
                   grep("bsd", all_licenses, value = TRUE),
                   grep("mit", all_licenses, value = TRUE),
                   grep("gpl", all_licenses, value = TRUE),
                   grep("mpl", all_licenses, value = TRUE))
license_levels <- c(license_levels, setdiff(all_licenses, license_levels))
ggplot(papers %>% 
           dplyr::mutate(repo_license = factor(repo_license, 
                                               levels = license_levels)),
       aes(x = repo_license)) +
    geom_bar() + 
    theme_bw() + 
    labs(x = "Software license", y = "Number of submissions", caption = dcap) + 
    theme(axis.title = element_text(size = 15),
          axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) + 
    facet_wrap(~ year(published.date), scales = "free_y")
```

```{r repl-license, class.source = 'fold-show', warning = FALSE, message = FALSE}
## For plots below, replace licenses present in less 
## than 2.5% of the submissions by 'other'
tbl <- table(papers$repo_license)
to_replace <- names(tbl[tbl <= 0.025 * nrow(papers)])
```

```{r plot-repo-license, class.source = 'fold-hide', warning = FALSE, message = FALSE}
ggplot(papers %>% 
           dplyr::mutate(year = year(published.date)) %>%
           dplyr::mutate(repo_license = replace(repo_license, 
                                                repo_license %in% to_replace,
                                                "other")) %>%
           dplyr::mutate(year = factor(year), 
                         repo_license = factor(
                             repo_license, 
                             levels = license_levels[license_levels %in% repo_license]
                         )) %>%
           dplyr::group_by(year, repo_license, .drop = FALSE) %>%
           dplyr::count() %>%
           dplyr::mutate(year = as.integer(as.character(year))), 
       aes(x = year, y = n, fill = repo_license)) + geom_area() + 
    theme_minimal() + 
    scale_fill_brewer(palette = "Set1", name = "Software\nlicense", 
                      na.value = "grey") + 
    theme(axis.title = element_text(size = 15)) + 
    labs(x = "Year", y = "Number of submissions", caption = dcap)

ggplot(papers %>% 
           dplyr::mutate(year = year(published.date)) %>%
           dplyr::mutate(repo_license = replace(repo_license, 
                                                repo_license %in% to_replace,
                                                "other")) %>%
           dplyr::mutate(year = factor(year), 
                         repo_license = factor(
                             repo_license, 
                             levels = license_levels[license_levels %in% repo_license]
                         )) %>%
           dplyr::group_by(year, repo_license, .drop = FALSE) %>%
           dplyr::summarize(n = n()) %>%
           dplyr::mutate(freq = n/sum(n)) %>%
           dplyr::mutate(year = as.integer(as.character(year))), 
       aes(x = year, y = freq, fill = repo_license)) + geom_area() + 
    theme_minimal() + 
    scale_fill_brewer(palette = "Set1", name = "Software\nlicense", 
                      na.value = "grey") + 
    theme(axis.title = element_text(size = 15)) + 
    labs(x = "Year", y = "Fraction of submissions", caption = dcap)
```

# Most common GitHub repo topics

```{r github-topics, class.source = 'fold-hide', fig.width = 12, fig.height = 12, warning = FALSE, message = FALSE}
a <- unlist(strsplit(papers$repo_topics, ","))
a <- a[!is.na(a)]
topicfreq <- table(a)

colors <- viridis::viridis(100)
set.seed(1234)
wordcloud::wordcloud(
    names(topicfreq), sqrt(topicfreq), min.freq = 1, max.words = 300,
    random.order = FALSE, rot.per = 0.05, use.r.layout = FALSE, 
    colors = colors, scale = c(10, 0.1), random.color = TRUE,
    ordered.colors = FALSE, vfont = c("serif", "plain")
)

DT::datatable(as.data.frame(topicfreq) %>% 
                  dplyr::rename(topic = a, nbr_repos = Freq) %>%
                  dplyr::arrange(desc(nbr_repos)),
              escape = FALSE, rownames = FALSE, 
              filter = list(position = 'top', clear = FALSE),
              options = list(scrollX = TRUE))
```


# Citation analysis

Here, we take a more detailed look at the papers that cite JOSS papers, using data from the Open Citations Corpus.

## Get citing papers for each submission

```{r get-citing-papers, class.source = 'fold-show', warning = FALSE, message = FALSE}
## Split into several queries
## Randomize the splitting since a whole query may fail if one ID is not recognized
papidx <- seq_len(nrow(papers))
idxL <- split(sample(papidx, length(papidx), replace = FALSE), ceiling(papidx / 50))
citationsL <- lapply(idxL, function(idx) {
    tryCatch({
        citecorp::oc_coci_cites(doi = papers$alternative.id[idx]) %>%
            dplyr::distinct() %>%
            dplyr::mutate(citation_info_obtained = as.character(lubridate::today()))
    }, error = function(e) {
        NULL
    })
})
citationsL <- citationsL[vapply(citationsL, function(df) !is.null(df) && nrow(df) > 0, FALSE)]
if (length(citationsL) > 0) {
    citations <- do.call(dplyr::bind_rows, citationsL)
} else {
    citations <- NULL
}
dim(citations)

if (!is.null(citations) && is.data.frame(citations) && "oci" %in% colnames(citations)) {
    citations <- citations %>% 
        dplyr::filter(!(oci %in% citations_archive$oci))
    
    tmpj <- rcrossref::cr_works(dois = unique(citations$citing))$data %>%
        dplyr::select(contains("doi"), contains("container.title"), contains("issn"),
                      contains("type"), contains("publisher"), contains("prefix"))
    citations <- citations %>% dplyr::left_join(tmpj, by = c("citing" = "doi"))
    
    ## bioRxiv preprints don't have a 'container.title' or 'issn', but we'll assume 
    ## that they can be 
    ## identified from the prefix 10.1101 - set the container.title 
    ## for these records manually; we may or may not want to count these
    ## (would it count citations twice, both preprint and publication?)
    citations$container.title[citations$prefix == "10.1101"] <- "bioRxiv"
    
    ## JOSS is represented by 'The Journal of Open Source Software' as well as 
    ## 'Journal of Open Source Software'
    citations$container.title[citations$container.title == 
                                  "Journal of Open Source Software"] <- 
        "The Journal of Open Source Software"
    
    ## Remove real self citations (cited DOI = citing DOI)
    citations <- citations %>% dplyr::filter(cited != citing)
    
    ## Merge with the archive
    citations <- dplyr::bind_rows(citations, citations_archive)
} else {
    citations <- citations_archive
    if (is.null(citations[["citation_info_obtained"]])) {
        citations$citation_info_obtained <- NA_character_
    }
}

citations$citation_info_obtained[is.na(citations$citation_info_obtained)] <- 
    "2021-08-11"

write.table(citations, file = "joss_submission_citations.tsv",
            row.names = FALSE, col.names = TRUE, sep = "\t", quote = FALSE)
```

## Summary statistics

```{r citation-summary-stats, class.source = 'fold-show', warning = FALSE, message = FALSE}
## Latest successful update of new citation data
max(as.Date(citations$citation_info_obtained))

## Number of JOSS papers with >0 citations included in this collection
length(unique(citations$cited))

## Number of JOSS papers with >0 citations according to OpenAlex
length(which(papers$citation_count > 0))
```

```{r citation-merge, class.source = 'fold-hide', warning = FALSE, message = FALSE}
## Number of citations from Open Citations Corpus vs OpenAlex
df0 <- papers %>% dplyr::select(doi, citation_count) %>%
    dplyr::full_join(citations %>% dplyr::group_by(cited) %>%
                         dplyr::tally() %>%
                         dplyr::mutate(n = replace(n, is.na(n), 0)),
                     by = c("doi" = "cited"))
```

```{r citation-fraction, class.source = 'fold-show', warning = FALSE, message = FALSE}
## Total citation count OpenAlex
sum(df0$citation_count, na.rm = TRUE)

## Total citation count Open Citations Corpus
sum(df0$n, na.rm = TRUE)

## Ratio of total citation count Open Citations Corpus/OpenAlex
sum(df0$n, na.rm = TRUE)/sum(df0$citation_count, na.rm = TRUE)
```

```{r citation-plot-crossref, class.source = 'fold-hide', warning = FALSE, message = FALSE}
ggplot(df0, aes(x = citation_count, y = n)) + 
    geom_abline(slope = 1, intercept = 0) + 
    geom_point(size = 3, alpha = 0.5) + 
    labs(x = "OpenAlex citation count", y = "Open Citations Corpus citation count",
         caption = dcap) + 
    theme_bw()

## Zoom in
ggplot(df0, aes(x = citation_count, y = n)) + 
    geom_abline(slope = 1, intercept = 0) + 
    geom_point(size = 3, alpha = 0.5) + 
    labs(x = "OpenAlex citation count", y = "Open Citations Corpus citation count",
         caption = dcap) + 
    theme_bw() + 
    coord_cartesian(xlim = c(0, 75), ylim = c(0, 75))
```

```{r citation-nbr-journals, class.source = 'fold-show'}
## Number of journals citing JOSS papers
length(unique(citations$container.title))
length(unique(citations$issn))
```

## Most citing journals

```{r citation-top-journals, class.source = 'fold-hide', message = FALSE}
topcit <- citations %>% dplyr::group_by(container.title) %>%
    dplyr::summarize(nbr_citations_of_joss_papers = length(cited),
                     nbr_cited_joss_papers = length(unique(cited)),
                     nbr_citing_papers = length(unique(citing)),
                     nbr_selfcitations_of_joss_papers = sum(author_sc == "yes"),
                     fraction_selfcitations = signif(nbr_selfcitations_of_joss_papers /
                                                         nbr_citations_of_joss_papers, digits = 3)) %>%
    dplyr::arrange(desc(nbr_cited_joss_papers))
DT::datatable(topcit,
              escape = FALSE, rownames = FALSE, 
              filter = list(position = 'top', clear = FALSE),
              options = list(scrollX = TRUE))
```

```{r citation-journals-plot, class.source = 'fold-hide'}
plotly::ggplotly(
    ggplot(topcit, aes(x = nbr_citations_of_joss_papers, y = nbr_cited_joss_papers,
                       label = container.title)) + 
        geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "grey") + 
        geom_point(size = 3, alpha = 0.5) + 
        theme_bw() + 
        labs(caption = dcap, x = "Number of citations of JOSS papers",
             y = "Number of cited JOSS papers")
)
plotly::ggplotly(
    ggplot(topcit, aes(x = nbr_citations_of_joss_papers, y = nbr_cited_joss_papers,
                       label = container.title)) + 
        geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "grey") + 
        geom_point(size = 3, alpha = 0.5) + 
        theme_bw() + 
        coord_cartesian(xlim = c(0, 100), ylim = c(0, 50)) + 
        labs(caption = dcap, x = "Number of citations of JOSS papers",
             y = "Number of cited JOSS papers")
)
```

```{r}
write.table(topcit, file = "joss_submission_citations_byjournal.tsv",
            row.names = FALSE, col.names = TRUE, sep = "\t", quote = FALSE)
```


# Save object

The tibble object with all data collected above is serialized to a file that can be downloaded and reused.

```{r save-data}
head(papers) %>% as.data.frame()
saveRDS(papers, file = "joss_submission_analytics.rds")
```

To read the current version of this file directly from GitHub, use the following code:

```{r, class.source = 'fold-show', eval = FALSE}
papers <- readRDS(gzcon(url("https://github.com/openjournals/joss-analytics/blob/gh-pages/joss_submission_analytics.rds?raw=true")))
```

# Session info

```{r session-info}
sessionInfo()
```

